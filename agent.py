"""
This module implements the Agent class, which is responsible for executing a plan
generated by the GOAP (Goal-Oriented Action Planning) system. The agent can handle
dynamic changes in the environment and will replan if an action fails or becomes
inapplicable due to events. It utilizes an event-driven system to adapt to changes.
"""

from typing import List, Dict
from action import Action
from event_manager import EventManager
from goal import Goal
from goap_planner import GOAPPlanner
from helpers import is_goal_satisfied


class Agent:
    def __init__(self, actions: List[Action], planner: GOAPPlanner, event_manager: EventManager, verbose: bool = True):
        """
        Initializes the Agent with a set of actions, a planner, and an event manager.

        Args:
            actions (List[Action]): The list of actions available to the agent.
            planner (GOAPPlanner): The planner used to generate action sequences.
            event_manager (EventManager): The event manager that handles external events.
            verbose (bool): If True, enables detailed logging of the agent's actions and state changes.
        """
        self.actions = actions
        self.planner = planner
        self.event_manager = event_manager
        self.should_replan = False
        self.verbose = verbose
        self.event_manager.subscribe(self.on_event)

    def on_event(self):
        """
        Event handler that sets the flag to indicate that a replan is required
        when an external event is detected.
        """
        if self.verbose:
            print("Event detected! Replanning required.")
        self.should_replan = True

    def execute_plan(self, initial_state: Dict[str, int], plan: List[str], context: Dict = None):
        """
        Executes the given plan, updating the agent's state, and replanning if necessary.

        Args:
            initial_state (Dict[str, int]): The starting state of the agent.
            plan (List[str]): The list of action names representing the plan to execute.
            context (Dict): Additional context, such as callbacks for state updates
                            or goal state, defaulting to None.
        """
        if context is None:
            context = {}

        plan_depth = 0
        plan_depths = []

        current_state = initial_state.copy()

        while plan:
            if self.verbose:
                print(f"Current State: {current_state}")
                print(f"Plan: {plan}")

            action_name = plan.pop(0)
            action = next((a for a in self.actions if a.name == action_name), None)

            plan_depth += 1

            if not action or not action.execute(current_state, on_interrupt=lambda: self.should_replan,
                                                verbose=self.verbose):
                self.should_replan = False

                if self.verbose:
                    print(f"Action {action_name} failed or interrupted. Replanning...")

                plan_depths.append(plan_depth)
                plan_depth = 0
                new_plan, _ = self.planner.plan(current_state, context.get("goals", None), context)
                if not new_plan:
                    if self.verbose:
                        print("No valid plan could be found during replanning!")
                    return

                plan = new_plan
                continue

            if "post_action_callback" in context:
                context["post_action_callback"](action, current_state, context)

            if "update_state_callback" in context:
                context["update_state_callback"](current_state, context)

            if self.verbose:
                print(f"Updated state after action {action_name}: {current_state}")

            goals = context.get("goals", None)
            goal_achieved = is_goal_satisfied(goals, current_state)

            if goal_achieved:
                if self.verbose:
                    print("Goal achieved!")
                break

            if len(plan) == 0 and not goal_achieved:
                if self.verbose:
                    print(f"Enf of plan reached, but goal not achieved. Replanning...")

                plan_depths.append(plan_depth)
                plan_depth = 0
                new_plan, _ = self.planner.plan(current_state, context.get("goals", None), context)
                if not new_plan:
                    if self.verbose:
                        print("No valid plan could be found during replanning!")
                    return

                plan = new_plan
                continue

        plan_depths.append(plan_depth)
        if self.verbose:
            print(f"Final State: {current_state}")
            print("Average action executed before replan: ", sum(plan_depths) / len(plan_depths))
